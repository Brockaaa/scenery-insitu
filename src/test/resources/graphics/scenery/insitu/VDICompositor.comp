#version 450
#extension GL_EXT_debug_printf : enable
#define USE_PRINTF 1

//layout(set = 4, binding = 0) uniform ShaderProperties {
//    bool doComposite;
//};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (set = 0, binding = 0, rgba32f) uniform readonly image3D VDIsColor;
layout (set = 1, binding = 0, r32f) uniform readonly image3D VDIsDepth;
layout (set = 2, binding = 0, rgba32f) uniform image3D CompositedVDIColor; //TODO: put loadstore
layout (set = 3, binding = 0, r32f) uniform image3D CompositedVDIDepth; //TODO: put loadstore

vec2 decode(vec4 c){
    vec2 v = vec2(0.);

    int ir = int(c.r*255.);
    int ig = int(c.g*255.);
    int irg = ir*256 + ig;
    v.x = float(irg) / 256.;

    int ib = int(c.b*255.);
    int ia = int(c.a*255.);
    int iba = ib*256 + ia;
    v.y = float(iba) / 256.;

    v -= 128.;
    return v;
}

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
float DecodeFloatRGBA (vec4 v) {
    return dot(v, bitDec);
}


void main() {

    ivec2 debug_pixel = ivec2(630, 360);

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Hello World!");
    }
    #endif

//    if(!doComposite) {
//        return;
//    }

    ivec3 imageCoords  = imageSize(VDIsColor);
    int numInputSupersegments = imageCoords.r;

    int frontSupersegment[50]; // which supersegment of this pixel are we currently looking at, for each process


//    for(int i = 0; i< 50; i++) {
//        imageStore(CompositedVDIColor, ivec2(i, gl_GlobalInvocationID.x), vec4(1));
//    }

    ivec3 opImageCoords  = imageSize(CompositedVDIColor);
    int numOutputSupersegments = opImageCoords.x;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Op image coords are: (%d, %d, %d)", opImageCoords.xyz);
    }
    #endif

//    int numProcesses = opImageCoords.g / opImageCoords.b; //TODO: generalize for non square images
    int numProcesses = 2;

    for (int i = 0; i<numProcesses; i++) {
        frontSupersegment[i] = 0;
    }

    float startDepth;
    float endDepth;
    vec4 colour;

    float lowDepth;
    int lowIndex;

    for(int i = 0; i<numOutputSupersegments; i++) {
        //Selecting which supersegment to place ith in the list

        startDepth = 0;
        endDepth = 0;
        colour = vec4(0);
        lowDepth = 65500;
        lowIndex = -1;

        for (int j = 0; j < numProcesses; j++) {
            if(frontSupersegment[j] >= numInputSupersegments) {
                continue;
            }

            float curStartDepth = imageLoad(VDIsDepth, ivec3(frontSupersegment[j] * 2, gl_GlobalInvocationID.y, j * opImageCoords.z + gl_GlobalInvocationID.x)).x;

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("For output supseg: %d, loaded start depth: %f from supseg: %d of process: %d", i, curStartDepth, frontSupersegment[j], j);
                debugPrintfEXT("Indexes used for fetching were: y: %d and z: %d", gl_GlobalInvocationID.y, j * opImageCoords.z + gl_GlobalInvocationID.x);
            }
            #endif

            if(curStartDepth < lowDepth && curStartDepth != 0) { //todo: improve empty detection
                lowDepth = curStartDepth;
                lowIndex = j;
                startDepth = curStartDepth;
                endDepth = imageLoad(VDIsDepth, ivec3(frontSupersegment[j] * 2 + 1, gl_GlobalInvocationID.y, j * opImageCoords.z + gl_GlobalInvocationID.x)).x;
                colour = imageLoad(VDIsColor, ivec3(frontSupersegment[j], gl_GlobalInvocationID.y, j * opImageCoords.z + gl_GlobalInvocationID.x)).rgba;
            }
        }

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("The %d th supseg has: start: %f, end: %f", i, startDepth, endDepth);
        }
        #endif

        imageStore(CompositedVDIDepth, ivec3(2 * i, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), vec4(startDepth, 0, 0, 0));
        imageStore(CompositedVDIDepth, ivec3(2 * i + 1, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), vec4(endDepth, 0, 0, 0));
        imageStore(CompositedVDIColor, ivec3(i, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), colour);
        if(lowIndex != -1) {
            frontSupersegment[lowIndex]++;
        }

        if((numInputSupersegments * numProcesses) <= i) {
            //If this o/p supersegment could not be written to due to insufficient inputs, make it 0
            imageStore(CompositedVDIDepth, ivec3(2 * i, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), vec4(0));
            imageStore(CompositedVDIDepth, ivec3(2 * i + 1, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), vec4(0));
            imageStore(CompositedVDIColor, ivec3(i, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x), vec4(0));
        }

    }


}
